# 最大フロー
- 制約に応じて辺を渡す←わかる
- スコア最大化したい←わかる
- コストを正で登録する←???
- find_argument←??????

頂点対を張るedgeという概念も正直慣れない
元気なときに[やる](https://atcoder.jp/contests/typical90/tasks/typical90_an)

```
#pragma GCC optimize("O3")
#ifdef LOCAL
#include "lib/std.hpp"
#endif

const int inf = 1001001001;

struct edge {
	int to, cap, rev;
	edge() : to(-1), cap(0), rev(-1) {};
	edge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};
};

bool find_argument(int u, int t, int step, vector<vector<edge>>& G, vector<bool>& visited) {
  if(u==t) return true;
  visited[u]=true;
  for(auto& e:G[u]) {
    if(visited[e.to] || e.cap < step) continue;
    if(find_argument(e.to, t, step, G, visited)) {
      e.cap -= step;
      G[e.to][e.rev].cap += step;
      return true;
    }
  }
  return false;
}

int max_flow(int s, int t, int maxstep, vector<vector<edge>>& G) {
  int flow=0, step=1;
  while(step*2<=maxstep) step<<=1;
  while(true) {
    vector<bool> visited(sz(G), false);
    if(!find_argument(s, t, step, G, visited)) {
      if(step==1) break;
      step>>=1;
    } else {
      flow+=step;
    }
  }
  return flow;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  
  int N, W; cin>>N>>W;
  vector<int> a(N);
  for(auto& e:a) cin>>e;

  vector<vector<edge>> G(N+2);
  auto add_edge = [&](int a, int b, int cap) {
    G[a].push_back(edge(b, cap, sz(G[b])));
    G[b].push_back(edge(b, 0, sz(G[a])-1));
  };

  for(int i=1; i<=N; ++i) {
    int K, c; cin>>K;
    for(int j=0; j<K; ++j) {
      cin>>c; add_edge(c, i, inf);
    }
  }
  for(int i=1; i<=N; ++i) {
    add_edge(0, i, a[i-1]);
    add_edge(i, N+1, W);
  }
  ll res=-max_flow(0, N+1, W, G);
  for(int i=0; i<N; ++i) res+=a[i];
  cout << res << endl;

  return 0;
}
```
